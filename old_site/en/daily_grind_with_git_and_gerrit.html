<!--:en-->Using Code Review is a great way to improve the quality of the code of your team. In order to automate what could otherwise be a very frustrating exercise, is a good tool. It is used by many projects including e.g. the Android operation system.
<h1>General Hints</h1>
<ul>
    <li><em>Always</em> work on a dedicated feature branch. Only after a change has been code reviewed, tested and verified should it be merged into the main development branch (usually <tt>master</tt>)</li>
</ul>
<h1>Recipies</h1>
The following are list of recipes on how to deal with situations that crop up in the daily work with Git and Gerrit and the necessary command statements to solve them. Most things may be obvious to a long time Git user, but for beginners the challenges may seem daunting at first.

In the following two differen remotes are used: gerrit and upstream. These may or may not be different. If you only use a single remote repository, substitude origin for both when issuing the git commands
<h2>Getting Started</h2>
Copy the data to your computer and create a working copy:
<pre>git clone ssh://gerrit.yourdomain.com/YourProject</pre>
<h2>Creating a Change</h2>
It is a very usefull practice to <strong>always</strong> use a branch on which to create your work
<pre>git checkout -b my-work-topic-branch -track upstream/</pre>
<h2>Retrieving changes made to the master</h2>
use rebase to do this.
<h2>Improving on a Change (with a prepared working directory)</h2>
if you have just pushed a change to gerrit, but want to add a further patch to the change, your working directory is already set up.
<pre>git commit -m"ChangeId: "
git rebase -i gerrit/master
git push gerrit HEAD:refs/for/</pre>
<h2>Improving on a Change (without prepared working directory)</h2>
This allows the creation of a new patch on change that was previously sent to Gerrit:
<pre>git checkout -b
git fetch gerrit refs/changes///
git cherry-pick FETCH_HEAD
&lt; do some work on the branch &gt;
git commit  -m"ChangeId: ...."
git push gerrit HEAD:refs/for/</pre>
Example:
<pre>git checkout -b new-features
git fetch gerrit refs/changes/345/345/2
git cherry-pick FETCH_HEAD
vi a_code_file.java
git commit -m "ChangeID: 54584350908a0f80943f0989e08980ad8098c"
git push HEAD:ref/for/new-features</pre>
<h2>Creating a new branch to work on</h2>
gi
<h1>Tool Integration</h1>
<h2>Eclipse</h2>
As the Eclipse Git integration, EGit currently does not support interactive rebasing to squash commits (e.g. <tt>git rebase -i HEAD~3</tt> to squash the last three commits), opening some other tool to work with Eclipse and Gerrit is required.

But still, since EGit has some support for Gerrit, using eclipse may help in working with a Gerrit based repository and process.
<h2>Configuring Push for Origin</h2>
<h1><a href="http://timadorus-web2.informatik.haw-hamburg.de/wp-content/uploads/2012/10/git_conf_eclipse.png"><img class="alignright size-medium wp-image-76" title="Configuring Git Push in Eclipse" src="http://timadorus-web2.informatik.haw-hamburg.de/wp-content/uploads/2012/10/git_conf_eclipse-300x271.png" alt="Configuring Push" width="300" height="271" /></a></h1>
As you can see in the image on the left, the push URL has to be set to the virtual branch '<tt>refs/for/*</tt>' for gerrit to assign a new change set.<!--:-->